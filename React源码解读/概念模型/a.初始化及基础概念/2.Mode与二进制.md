(简略)

### React 为什么要有这么多模式?

- 官方回答: 我们认为提供<font color="orange" size="4">渐进的迁移策略</font>比进行破坏性的更改或使 React 停滞不前是更好的选择。

- 迁移路径: `legacy -> blocking -> concurrent`

### React 中的模式: Mode

- 文件: ReactTypeOfMode.js

- 并发模式: `ConcurrentMode`, 未来的主要模式

- 遗留严格模式: `StrictLegacyMode`, 向下兼容的遗留模式(检查废弃/潜在问题)

- 性能调试模式: `ProfileMode`, 一般触发 actual 相关的性能指标

  ```javascript
  const mode = fiber.mode;
  // 如果不是并发模式, 是没有优先级的, 只能取同步更新
  if ((mode & ConcurrentMode) === NoMode) {
    return (SyncLane: Lane);
  }
  ```

### 二进制的排列组合状态

- 用`集合`的思想来理解 React 的二进制用法, 更多查看后续 Lanes 模型

- 二进制排列组合(状态压缩)算法, 可以表示`多个` `批量`的概念, 如 排序组合 / 权限校验 / 掩码过滤 / Lanes 模型 / 状态压缩(贪心和 DP 算法)

- 具体代码

  ```javascript
  // 是否有交集
  ((mode & ConcurrentMode) ===
    NoMode(
      // 是否为父集子集关系
      mode & ConcurrentMode
    )) ===
    ConcurrentMode;

  export function includesSomeLane(a: Lanes | Lane, b: Lanes | Lane) {
    return (a & b) !== NoLanes;
  }

  export function isSubsetOfLanes(set: Lanes, subset: Lanes | Lane) {
    return (set & subset) === subset;
  }

  // 取反抵消掉自身
  export function removeLanes(set: Lanes, subset: Lanes | Lane): Lanes {
    return set & ~subset;
  }

  // -a === ~a + 1;
  // 原数 a = 0b110100
  // 补码 b = 0b001011
  // 加一 c = 0b001100
  // a & c = 0b110100 & 0b001100 = 0b000100, 也就是最低位的1
  export function getHighestPriorityLane(lanes: Lanes): Lane {
    return lanes & -lanes;
    return lanes & (~lanes + 1);
  }

  flags & Placement;
  flags & Update;
  ```
