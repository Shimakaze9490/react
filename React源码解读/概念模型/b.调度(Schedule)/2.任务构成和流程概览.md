### 任务'task'的数据结构

- Scheduler 是个独立的包, 入口文件: `scheduler/src/forks/Scheduler.js`
  ```javascript
  var newTask = {
    id: taskIdCounter++,
    callback, // 最终要执行的函数
    priorityLevel, // 传进来的优先级
    startTime,
    expirationTime, // 过期时间
    sortIndex: -1, // 优先队列的排序依据
  };
  ```
- 维护任务的队列: taskQueue / timerQueue

- callback 与 continuationCallback

### 三个重要时间与优先级处理

- 开始时间，当前时间，延迟时间

- 确定开始执行的时间:

  ```javascript
  startTime = currentTime + delay;
  ```

- 处理优先级, timeout 与 proirityLevel 的关系; `timeout = fn(proirityLevel);`
  如, 在动画频繁绘制的页面, useEffect 最大可能被延迟 5 秒执行

- 确定过期时间, 关乎任务饥饿问题!

  ```javascript
  expirationTime = startTime + timeout;
  ```

- 举例: 比如当前时间(currentTime)为 10s, NormalPriority 换算成 timeout 为 5000ms,
  所以这个任务的过期时间(expirationTime)为 15s, 那这个任务会在什么时候执行呢?

  如果前面一直有更紧急的任务, 该任务最多被推迟到 15s, 进入过期状态, 被强制执行,
  如果前面任务已经执行完了, 未过期的任务也会提前执行。

### 锁的使用: 保证过程执行的唯一(类比单例模型)

- `isHostTimeoutScheduled` 是否正倒计时中

- `isHostCallbackScheduled / isMessageLoopRunning` 是否执行调度中(宏任务中)

- `isPerformingWork` 是否执行任务中

### 取消任务倒计时

- 为什么要取消任务? 什么场景: 三种情况

  进入正式执行任务前 / 线程空闲将任务提前执行 / 高优先级打断低优先级(ensureRootIsScheduled)

- `cancelHostTimeout -> localClearTimeout`

### 如何结束时间切片, 如何结束当前的代码执行(两种情况)

- 在调度过程: `shouldYieldToHost`

- 在执行流程: `shouldYield`

### 流程概览

- 1. 先开始倒计时: `requestHostTimeout`(是对 setTimeout 的封装)

- 2. 时间到了: `handleTimeout`

- 3. 同步两个队列先: `advanceTimer`

- 4. 开启时间切片: `requestHostCallback`(是对 requestIdleCallback 的模拟) -> `performWorkUntilDeadline`
     全局变量`startTime = currentTime`, 登记每一次时间切片的开始时刻, 用于计算耗时

- 5. 启动宏任务: `port.postMessage` + `port.onmessage`(就是 performWorkUntilDeadline)

- 5. 切片内容: `flushWork`(就是 scheduledHostCallback) + `workLoop`(可能执行多个小任务)
     workLoop 返回`hasMoreWork`

- 6. 执行任务: `const continuationCallback = callback(didUserCallbackTimeout);`

- 7. 注意: 区分宏任务的前后两端, 需要全局变量来维护状态(因为执行栈会被清空);
     requestHostCallback 的理解要结合 rIC;
     堆不能从中间删除元素, 只能删除堆顶的元素
