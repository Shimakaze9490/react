(简略)

### 切换双缓存

```javascript
root.current = finishedWork; // finishedWork 就是 workInProgress
```

### 提交后阶段: commitLayoutEffects

- 同样遍历到`commitLayoutEffectOnFiber`, 生命周期`componentDidMount`

- 触发`Layout`类型的副作用

  ```javascript
  commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);
  ```

- commitAttachRef 处理 Ref 属性的更新

### 最后 commit 阶段收尾 \*\*\*

- `passiveEffects` 另起一个调度去执行'useEffect', 异步的、延时的、非阻塞的

- `requestPaint`: 通过`shouldYieldToHost`结束本次调度的`workLoop`, 保证是该时间切片内最后一个任务。

  ```javascript
  // Tell Scheduler to yield at the end of the frame, so the browser has an
  // opportunity to paint.
  requestPaint(); // Scheduler.unstable_requestPaint
  ```

- 重走调度流程: `ensureRootIsScheduled(root, now());`
  因为可能有被跳过的低优先级更新，或者在本次调度期间又产生了更新。(低优先级任务也是任务)

- flushPassiveEffects 与 flushSyncCallbacks

  ```javascript
  // 如果在上面的LayoutEffect, 中触发了其他的副作用, 同步调用它
  // 如: useLayoutEffect --> 里面执行了setState, 那这个setState就会同步更新!
  // If layout work was scheduled, flush it now.
  ```

- `markNestedUpdateScheduled`
  标记是否为无限嵌套的更新调度
