### 回顾副作用

- [4.副作用与 Update.md](<../c.协调(Reconcile)/4.副作用与Update.md>)

### use(Layout)Effect 的结构与入口

- 文件: ReactFiberHooks.old.js

- 入口: `dispater -> updateEffect(mountEffect) -> updateEffectImpl(mountEffectImpl)`

- `mountEffectImpl`挂载阶段, 全部执行一遍; `updateEffectImpl`更新阶段, 进行 deps 比对;

- 数据结构(链表对象): `hook.memorizedState`下的 `create` / `destroy` / `deps` / `tag` (忽略 queue 相关, 比较难懂)

### 判断依赖 Deps

- 为什么当依赖不存在时每次都更新? 因为跳过了拦截的比对

- 为什么当依赖为空数组时仅更新一次? 因为跳过了比对的遍历

- `areHookInputsEqual(nextDeps, prevDeps)` 与 `Object.is`

- 不满意`Object.is`作为依赖判断的话, 可以选择拦截掉依赖自行判断;
  如, ahooks 的`createDeepCompareEffect`中就自行进行了深度比较。

### 第一大阶段, render 阶段

- 内容概括: 打上标记、汇入统一的副作用模型, 等待 commit 阶段才正式执行。

- 统一的入口(updateEffectImpl) / 区别的标志(fiberFlags) / 依赖判断(deps)
  HookHasEffect / 产生新的 Effect 对象 / 推入循环链表 fiber.updateQueue

### 第二大阶段, commit 阶段

- 内容概括: 根据 render 阶段构成的链表, 在不同阶段执行对应的副作用
  所以这条链表会被多次`while`循环执行, 匹配出本次对应类型的副作用执行。

- 对于 useLayoutEffect 执行路径: `commitRoot -> flushPassiveEffects -> commitPassiveUnmountEffects/commitPassiveMountEffects -> commitPassiveMountOnFiber(根据fiber类型执行其对应副作用) -> commitHookEffectListMount`
  判断本次执行副作用的类型: `if ((effect.tag & flags) === flags)`
  核心代码: `effect.destroy = create();`

- 执行 effect 又包括两个阶段: 先 Unmount, 再 Mount
  先 `commitPassiveUnmountEffects` --> `destroy` / `deletions`
  后 `commitPassiveMountEffects` --> `create`

- 执行顺序: useLayoutEffect --> 浏览器的刷新(layout/repaint) --> (帧结束、下一帧) --> useEffect --> 浏览器的刷新(layout/repaint)

### useEffect 的执行为什么是异步的、延后的、非阻塞的?

- <img src="../../imgs/passiveEffects.png" style="border: 1px solid green" />

- 核心代码:

  ```javascript
  // If there are pending passive effects, schedule a callback to process them.
  scheduleCallback(NormalSchedulerPriority, () => {
    flushPassiveEffects();
    return null;
  });
  ```

- `因为整个useEffect(passive) 都是重新产生一次调度去执行的, 也就是并非在本次宏任务(时间切片)内。`
  `因为是Normal优先级进入的调度队列, 什么时候能出来是不确定的, 在极端情况下(如动画渲染很多), 最多延迟5秒(expirationTime)才会执行!`
  `这就是为什么说useEffect性能更好, 因为ta的执行不会阻塞本次周期内的(commit执行)页面渲染`

- 后续流程与 useLayoutEffect 一致

### 总结与最佳实践

- `保持useEffect代码内聚易维护`, 不要将关联代码分散到多个 effect, 也不要将语义不用的两部分 effect 写到一起。

- 如果状态的更新比较复杂, 推荐使用`useReducer`代替`useState + useEffect`

- 有必要的话, 给`useEffect`加上防抖节流, `useDebounceEffect` `useThrottleEffect`

- 按照官方范式写好依赖 Deps

- 不要忘记`destroy`方法, 对于有`重置状态, 释放资源`的需求时能派上用场。

- 造成闪烁

TODO
