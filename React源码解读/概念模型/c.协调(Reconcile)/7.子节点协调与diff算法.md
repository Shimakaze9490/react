### 子节点层的协调入口(reconcileChildren)

- 也就是由一个节点向下构造其子树: `由于是向下递推的, 每次只考虑子一层, 第 n 层为父级, 第 n+1 层为子级`
  初始化: `workInProgress.child = mountChildFibers`
  更新 diff: `workInProgress.child = reconcileChildFibers`
  也就是 `fiber.child = child0 -> child1 -> child2`

### 理解 diff 前置知识

- element 中如何表示子级: pendingProps.children

- 在协调子节点中比对的双方, 旧的是 fiber 链表, 新的是 element 元素(数组)
  整个过程是 element 数组转换成整个`child`fiber 链表的过程!

- 协调(diff)的语义: reconcile 是整个协调执行阶段, diff 是其中用于协调子节点的算法;
  一个 fiber 节点下面有`多个子节点`, 在`新旧两次快照`中, 如何尽可能高效的`有限复用旧的节点`, 达到性能最快

- 比对的双方: 旧的是 `fiber 链表`, 新的是 `element 数组`,
  如, 上一个快照有 n 个 child 节点的链表, 这一个快照有 m 个 element 元素数组, 两者进行 diff!

- `协调是有限的复用` 理解其三个限制: `同级比较` / `同类型元素比较` / `唯一key比较`

- 算法: 如何 O(m + n)复杂度找出两个数组的交集? 答案是 hash Map

### 单节点 diff 及 边界情况 & reconcileSingleElement

- 需要判断`$$typeof`: `fragment` / `null` / `文本` / `数字`

- 当节点可以复用`useFiber` / 当节点不能复用`createFiberFromElement`
  `const existing = useFiber(child, element.props);`

- 删除多余节点 `deleteRemainingChildren(returnFiber, child.sibling);`

- 其余的情况全部当做`newChild`不存在, 执行删除`deleteRemainingChildren`

### 多节点 diff

- 多节点处理流程: `reconcileChildrenArray --> updateSlot --> useFiber -> createWorkInProgress`

- 核心是遍历双方(要先清晰的理解双方是谁!), 转换成上面单个 的情况来处理。会有个问题, 就是判断节点 `移动Place` (vue 的 diff 是首尾 4 指针, 找最长递增子序列)

- 找到第一个匹配不上的节点: 也就是`updateSlot`返回的结果为 null

- 什么是 PlaceChild: `lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);`

- 处理移动: `PlaceChild`; 处理比对: `updateSlot`;
  处理删除: `deleteChild`; 处理新增: `createChild`;
  构造哈希: `mapRemainingChildren`;

### 数组(新)与链表(旧)比对过程

- 两边同时向前走(匹配), 相同的节点直接复用, 直到第一个不相同的节点!
  比如,

  ```javascript
  const newFiber = updateSlot();
  if (newFiber === null) {
  }
  ```

- 此时, 如果链表(旧)还有剩, 则依次删除
  旧链表: `1 -> 2 -> 3 -> 4 -> 5`
  新数组: `[1, 2, 3]`
  旧链表上的`4 -> 5` 会被删除

  此时, 如果数组(新)还有剩, 则依次新增并追加
  旧链表: `1 -> 2 -> 3`
  新数组: `[1, 2, 3, 4, 5, 6]`
  多次的`[4, 5, 6]` 会被依次新增追加

  最复杂的是两边都还有剩, 但是出现了不匹配, 如何找出两者的交集?
  旧链表: `1 -> 2 -> 3 -> 4 -> 5`
  新数组: `[3, 4, 5, 1, 2]`
  `[1, 2]`被移到了最后, 触发`PlaceChild`位移的判断

  旧链表: `1 -> 2 -> 3 -> 4 -> 5`
  新数组: `[1, 7, 4, 3]`
  将剩余`oldFiber`构造成 hash Map, 在剩余数组中匹配出来复用

- 最终返回新的子 fiber 链表头即可: `fiber.child = resultingFirstChild`
